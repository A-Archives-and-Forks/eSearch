# 截屏

使用`node-screenshot`库，Wayland 平台调用了桌面的截屏软件，再读取图片，所以会有些慢。由于该库暂不支持 Linux Arm64，所以我在 nodejs 下模仿类似的操作，读取设置里的命令，调用外部截屏软件，然后读取图片。

## 坐标

canvas 坐标与数学上的一致，在左上角的一个像素点应为`(0, 0)` `1x1`的矩形。包括图片的裁切，实际上是 canvas 上的整数矩形坐标。这些整数坐标描述了整数方格的一个个交点。对于框选和获取元素定位来说，这些**数学坐标**是最重要的。所以理论上，大小栏和鼠标跟随栏的坐标应该是数学坐标，放大镜的中心点应为相交线。

而我们需要的取色器却要获取一个像素点的信息，准确来说，是一个范围，一个 1x1 的矩形，也可以近似为 n.5 的信息，我们可以把他成为**像素坐标**。在取色器上，此时的坐标又应该是像素坐标，放大镜中间应该是中心像素。

![数学坐标和像素坐标示意图](assets/zb.svg)

大小栏和裁切都用数学坐标，矛盾在于鼠标跟随栏的显示坐标和放大镜的显示。他们如何取舍？又如何统一？我打算让他们根据不同的场景使用不同的坐标。我们在取色时，只需要移动鼠标，在框选时，不需要关注鼠标位置的颜色，而是通过放大镜来定位。所以在鼠标按住时（改变框选），显示数学坐标，放大镜宽度为偶数，隐藏取色器，在鼠标松开时，显示像素坐标，放大镜宽度为奇数，显示取色器。

下面我们来考虑具体的实现，鼠标事件获取的一系列坐标表示什么，如何把他们转化为数学坐标和像素坐标？

![鼠标坐标](assets/mouse_zb.svg)

在 Chrome 126（Linux Wayland） 实验可知，鼠标事件的坐标都是整数，应该是经过`math.round`转换后的数学坐标。比如$(1.5, 2.5)$都被映射成$2$。我们需要的整数数学坐标直接使用鼠标事件的坐标即可。

至于像素坐标，由于鼠标事件无法提供精确的坐标，所以我们无法计算。我们可以简单

## 广截屏

即滚动截屏

思路：获取滚动前后位移，拼接

由于我们很难通过系统 API 层面获取滚动的像素，比如一些网页可以监听滚动事件自己设置滚动距离，所以我们通过分析图片来获取滚动距离。

需要至少两张截屏图片，一张滚动前，一张滚动后。使用`uiohook-napi`获取鼠标滚动事件和方向键，也可以定时截屏。

可以通过特征点算法来分析图片位移，但`opencv.js`没有提供，所以我只使用了最简单的模板匹配算法。

由实践可知，模板需要小于源图片大小，否则匹配结果不准确，所以我们需要裁切第二张图片。

还要考虑的是一些界面有固定元素，比如导航栏等，我们可以通过异或算法来消除这些固定元素，但在 eSearch 中，我使用了简单的裁切，一般固定元素在图片四周，所以我们自己裁切，大部分情况下效果不错。

举个例子：有“目”字形的页面结构，第 1、3 个“口”可能是固定元素，第 2 可能是滚动元素。我们预期得到一个中间长，上下固定元素均保留的长截屏。我们裁切第 2 作为模板，匹配上一张截屏，得到位移。如果位移向下，把 2、3 覆盖到上一张截屏，这样 1 保留，2 延伸，并覆盖了上一张的 3。其他方向同理，如果考虑上下左右滚动的广截屏，以九宫格来切割。

![广截屏示意图](assets/long_clip.svg)
